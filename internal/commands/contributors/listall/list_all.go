package listall

import (
	"encoding/csv"
	"errors"
	"fmt"
	"github.com/MakeNowJust/heredoc/v2"
	"github.com/google/go-github/v63/github"
	"github.com/jsumners/ghm/internal/app"
	"github.com/spf13/cobra"
	"net/http"
	"os"
	"slices"
	"strings"
)

var longDesc = heredoc.Doc(`
	Generate a list of all people that have contributed to a repository, or
	all repositories in an organization, between two git refs. By default, it
	will compare the latest head ref on the main branch with the latest release
	ref (ignoring any pre-release marked releases).
`)

var repoName string
var startRef string
var endRef string
var refsCsv string

func New(app *app.App) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "list-all",
		Short: "List all contributors between two refs",
		Long:  longDesc,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runE(app)
		},
	}

	cmd.Flags().StringVarP(
		&app.Owner,
		"owner",
		"o",
		"",
		"The user/org containing the repo(s) to target.",
	)
	cmd.MarkFlagRequired("owner")

	cmd.Flags().StringVarP(
		&repoName,
		"repo-name",
		"r",
		"",
		"Specific repository to target.",
	)
	cmd.Flags().StringVarP(
		&startRef,
		"start-ref",
		"s",
		"",
		"Git ref marking the starting commit.",
	)
	cmd.Flags().StringVarP(
		&endRef,
		"end-ref",
		"e",
		"",
		"Git ref marking the ending commit.",
	)

	cmd.Flags().StringVarP(
		&refsCsv,
		"refs-csv",
		"f",
		"",
		"CSV of repos and refs as generated by `refs recent-releases`.",
	)
	cmd.MarkFlagsMutuallyExclusive("refs-csv", "repo-name")

	cmd.MarkFlagsOneRequired("repo-name", "refs-csv")

	return cmd
}

type Contributor struct {
	HasSponsorPage bool
	Repos          []string
}

func runE(app *app.App) error {
	contributors := map[string]Contributor{}

	if repoName != "" {
		// Only working on a single repo.
		if endRef == "" {
			ref, err := getMainBranchLastCommit(app, repoName)
			if err != nil {
				return err
			}
			endRef = ref
		}

		if startRef == "" {
			release, err := getLatestRelease(app, repoName)
			if err != nil {
				return err
			}
			ref, err := getTagLastCommit(app, repoName, release.GetTagName())
			if err != nil {
				return err
			}
			startRef = ref
		}

		usernames, err := listAll(app, repoName, startRef, endRef)
		if err != nil {
			return err
		}
		for _, username := range usernames {
			contributors[username] = Contributor{
				HasSponsorPage: hasSponsorPage(username, app.Client.Client()),
				Repos:          []string{repoName},
			}
		}
	} else {
		// Parse and iterate the CSV.
		file, err := os.Open(refsCsv)
		if err != nil {
			return err
		}
		reader := csv.NewReader(file)
		reader.TrimLeadingSpace = true
		records, err := reader.ReadAll()

		// We don't need the header row.
		records = slices.Delete(records, 0, 1)
		// TODO: figure out a safe way to do this concurrently
		for _, record := range records {
			usernames, err := listAll(app, record[0], record[2], record[1])
			if err != nil {
				// TODO: do something better than bailing?
				return err
			}
			for _, username := range usernames {
				contributor, ok := contributors[username]
				if !ok {
					contributor = Contributor{
						HasSponsorPage: hasSponsorPage(username, app.Client.Client()),
						Repos:          []string{record[0]},
					}
				} else {
					contributor.Repos = append(contributor.Repos, record[0])
				}
				contributors[username] = contributor
			}
		}
	}

	displayResults(contributors)

	return nil
}

func displayResults(contributors map[string]Contributor) {
	fmt.Println("contributor, sponsor link, repos")
	sortedKeys := mapToSlice(contributors)
	for _, key := range sortedKeys {
		contributor := contributors[key]
		slices.Sort(contributor.Repos)
		link := ""
		if contributor.HasSponsorPage {
			link = fmt.Sprintf("[❤️ sponsor](https://github.com/sponsors/%s)", key)
		}
		fmt.Printf("%s, %s, %s\n", key, link, strings.Join(contributor.Repos, "; "))
	}
}

// listAll gets a list of all commits between two references, iterates the
// set of commits, and collects the usernames for all of those commits into
// a unique set. The result is a set of usernames that contributed to the
// repository between the start and end references.
func listAll(app *app.App, repoName string, startRef string, endRef string) ([]string, error) {
	result, _, err := app.Client.Repositories.CompareCommits(app.Context, app.Owner, repoName, startRef, endRef, nil)
	if err != nil {
		return nil, err
	}

	if result.GetStatus() == "identical" {
		return nil, errors.New("latest release ref matches starting ref, nothing to report")
	}

	contributors := map[string]int{}
	for _, commit := range result.Commits {
		author := commit.GetAuthor()
		if author == nil {
			continue
		}

		username := author.GetLogin()
		if strings.HasPrefix(username, "dependabot") {
			continue
		}
		if username == "" {
			continue
		}

		contributors[username] = 0
	}

	names := make([]string, 0)
	for s, _ := range contributors {
		names = append(names, s)
	}
	return names, nil
}

func mapToSlice(input map[string]Contributor) []string {
	result := make([]string, 0)
	for s, _ := range input {
		result = append(result, s)
	}
	slices.Sort(result)
	return result
}

func hasSponsorPage(username string, httpClient *http.Client) bool {
	u := fmt.Sprintf("https://github.com/sponsors/%s", username)
	httpClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if strings.HasSuffix(req.Response.Header.Get("Location"), "com/"+username) {
			return errors.New("skip redirect")
		}
		return nil
	}
	defer func() {
		httpClient.CheckRedirect = nil
	}()

	req, err := http.NewRequest(http.MethodGet, u, nil)
	if err != nil {
		return false
	}

	_, err = httpClient.Do(req)
	if err != nil {
		return false
	}

	return true
}

func getMainBranchLastCommit(app *app.App, repoName string) (string, error) {
	repo, _, err := app.Client.Repositories.Get(app.Context, app.Owner, repoName)
	if err != nil {
		return "", err
	}
	mainBranch := repo.GetDefaultBranch()

	if mainBranch == "" {
		mainBranch = repo.GetMasterBranch()
		if mainBranch == "" {
			return "", errors.New("cannot find main branch name")
		}
	}

	branch, _, err := app.Client.Repositories.GetBranch(app.Context, app.Owner, repoName, mainBranch, 0)
	if err != nil {
		return "", err
	}
	mainLastCommit := branch.GetCommit().GetSHA()

	return mainLastCommit, nil
}

func getLatestRelease(app *app.App, repoName string) (*github.RepositoryRelease, error) {
	listOpts := &github.ListOptions{PerPage: 100}

	releases := make([]*github.RepositoryRelease, 0)
	for {
		_releases, resp, err := app.Client.Repositories.ListReleases(app.Context, app.Owner, repoName, listOpts)
		if err != nil {
			return nil, err
		}
		releases = append(releases, _releases...)

		if resp.NextPage == 0 {
			break
		}
		listOpts.Page = resp.NextPage
	}

	// Sort most recent to oldest, i.e. first element is the latest release.
	slices.SortFunc(releases, func(a, b *github.RepositoryRelease) int {
		if a.PublishedAt.Before(b.PublishedAt.Time) {
			return 1
		}
		if b.PublishedAt.Before(a.PublishedAt.Time) {
			return -1
		}
		return 0
	})

	return releases[0], nil
}

func getTagLastCommit(app *app.App, repoName string, tag string) (string, error) {
	sha, _, err := app.Client.Repositories.GetCommitSHA1(app.Context, app.Owner, repoName, tag, "")
	return sha, err
}
